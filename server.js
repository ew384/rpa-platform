// server.js - RPA Platform ÂêéÁ´ØÊúçÂä°Âô® (ÂÆåÊï¥Áâà)
const express = require('express');
const multer = require('multer');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const { spawn } = require('child_process');
const fetch = require('node-fetch'); // Á°Æ‰øùÂ∑≤ÂÆâË£Ö: npm install node-fetch@2

const app = express();
const PORT = process.env.PORT || 3001;

// Electron HTTP API ÈÖçÁΩÆ
const ELECTRON_API_PORT = 9528; // ‰∏é Electron ‰∏≠ÁöÑÁ´ØÂè£‰øùÊåÅ‰∏ÄËá¥
const ELECTRON_API_BASE = `http://localhost:${ELECTRON_API_PORT}`;

// ‰∏≠Èó¥‰ª∂
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ÂàõÂª∫ÂøÖË¶ÅÁöÑÁõÆÂΩï
const UPLOAD_DIR = path.join(__dirname, 'uploads');
const TEMP_DIR = path.join(__dirname, 'temp');
const LOGS_DIR = path.join(__dirname, 'logs');

[UPLOAD_DIR, TEMP_DIR, LOGS_DIR].forEach(dir => {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
});

// ÈÖçÁΩÆÊñá‰ª∂‰∏ä‰º†
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        let uploadPath = UPLOAD_DIR;

        // Ê†πÊçÆÊñá‰ª∂Á±ªÂûãÂàÜÁ±ªÂ≠òÂÇ®
        if (file.mimetype.startsWith('video/')) {
            uploadPath = path.join(UPLOAD_DIR, 'videos');
        } else if (file.mimetype.startsWith('image/')) {
            uploadPath = path.join(UPLOAD_DIR, 'images');
        } else if (file.mimetype.startsWith('audio/')) {
            uploadPath = path.join(UPLOAD_DIR, 'audio');
        }

        if (!fs.existsSync(uploadPath)) {
            fs.mkdirSync(uploadPath, { recursive: true });
        }

        cb(null, uploadPath);
    },
    filename: (req, file, cb) => {
        // ÁîüÊàêÂîØ‰∏ÄÊñá‰ª∂Âêç
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        const ext = path.extname(file.originalname);
        cb(null, `${file.fieldname}-${uniqueSuffix}${ext}`);
    }
});

const upload = multer({
    storage,
    limits: {
        fileSize: 500 * 1024 * 1024 // 500MB ÈôêÂà∂
    },
    fileFilter: (req, file, cb) => {
        // Êñá‰ª∂Á±ªÂûãÈ™åËØÅ
        const allowedTypes = /video|image|audio/;
        const mimeType = allowedTypes.test(file.mimetype);

        if (mimeType) {
            cb(null, true);
        } else {
            cb(new Error('‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Á±ªÂûã'), false);
        }
    }
});

// Â≠òÂÇ®Ê¥ªË∑ÉÁöÑÂ∑•‰ΩúÊµÅÊâßË°å
const activeWorkflows = new Map();

// ============ Electron API ÈõÜÊàêÂáΩÊï∞ ============

// Ê£ÄÊü• Electron HTTP API ÊòØÂê¶ÂèØÁî®
async function checkElectronApiAvailability() {
    try {
        const response = await fetch(`${ELECTRON_API_BASE}/api/health`, {
            method: 'GET',
            timeout: 3000
        });
        return response.ok;
    } catch (error) {
        return false;
    }
}

// ‰ªé Electron HTTP API Ëé∑ÂèñÊµèËßàÂô®ÂÆû‰æã
async function getBrowserInstancesFromElectron() {
    try {
        console.log('[BrowserAPI] üîó Calling Electron HTTP API...');

        const response = await fetch(`${ELECTRON_API_BASE}/api/browsers`, {
            method: 'GET',
            timeout: 5000
        });

        if (!response.ok) {
            throw new Error(`Electron API responded with ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();
        if (!result.success) {
            throw new Error(result.error || 'Electron API returned unsuccessful response');
        }

        console.log(`[BrowserAPI] ‚úÖ Successfully got ${result.browsers.length} browsers from Electron`);
        return result.browsers;
    } catch (error) {
        console.error('[BrowserAPI] ‚ùå Failed to get browsers from Electron HTTP API:', error.message);
        throw error;
    }
}

// Ëé∑ÂèñÁâπÂÆöÊµèËßàÂô®ÁöÑËØ¶ÁªÜ‰ø°ÊÅØ
async function getBrowserDetailsFromElectron(browserId) {
    try {
        const response = await fetch(`${ELECTRON_API_BASE}/api/browser/${browserId}`, {
            method: 'GET',
            timeout: 3000
        });

        if (!response.ok) {
            throw new Error(`Failed to get browser details: ${response.status}`);
        }

        const result = await response.json();
        return result.success ? result.browser : null;
    } catch (error) {
        console.error(`[BrowserAPI] Failed to get browser details for ${browserId}:`, error.message);
        return null;
    }
}

// Ëé∑ÂèñÊµèËßàÂô®Ê†áÁ≠æÈ°µ‰ø°ÊÅØ
async function getBrowserTabsFromElectron(browserId) {
    try {
        const response = await fetch(`${ELECTRON_API_BASE}/api/browser/${browserId}/tabs`, {
            method: 'GET',
            timeout: 3000
        });

        if (!response.ok) {
            throw new Error(`Failed to get browser tabs: ${response.status}`);
        }

        const result = await response.json();
        return result.success ? result.tabs : [];
    } catch (error) {
        console.error(`[BrowserAPI] Failed to get browser tabs for ${browserId}:`, error.message);
        return [];
    }
}

// ============ API Ë∑ØÁî± ============

// ÂÅ•Â∫∑Ê£ÄÊü•
app.get('/api/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        service: 'RPA Platform Backend'
    });
});

// Ëé∑ÂèñÂèØÁî®ÁöÑÂ∑•‰ΩúÊµÅÁ±ªÂûã
app.get('/api/workflows', (req, res) => {
    res.json({
        success: true,
        workflows: [
            {
                type: 'video',
                name: 'ËßÜÈ¢ëÂèëÂ∏É',
                description: '‰∏ä‰º†ËßÜÈ¢ëÂà∞ÂæÆ‰ø°ËßÜÈ¢ëÂè∑',
                supportedFormats: ['mp4', 'avi', 'mov']
            },
            {
                type: 'article',
                name: 'ÂõæÊñáÂèëÂ∏É',
                description: 'ÂèëÂ∏ÉÂõæÊñáÂÜÖÂÆπ',
                supportedFormats: ['jpg', 'png', 'jpeg']
            },
            {
                type: 'music',
                name: 'Èü≥‰πêÂèëÂ∏É',
                description: '‰∏ä‰º†Èü≥‰πêÂÜÖÂÆπ',
                supportedFormats: ['mp3', 'wav', 'm4a']
            },
            {
                type: 'audio',
                name: 'Èü≥È¢ëÂèëÂ∏É',
                description: '‰∏ä‰º†Èü≥È¢ëÂÜÖÂÆπ',
                supportedFormats: ['mp3', 'wav', 'ogg']
            }
        ]
    });
});

// Êñá‰ª∂‰∏ä‰º†Êé•Âè£
app.post('/api/upload', upload.single('file'), (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({
                success: false,
                error: 'Ê≤°Êúâ‰∏ä‰º†Êñá‰ª∂'
            });
        }

        console.log('[Upload] Êñá‰ª∂‰∏ä‰º†ÊàêÂäü:', req.file.filename);

        res.json({
            success: true,
            file: {
                id: req.file.filename,
                originalName: req.file.originalname,
                filename: req.file.filename,
                path: req.file.path,
                size: req.file.size,
                mimetype: req.file.mimetype,
                uploadTime: new Date().toISOString()
            }
        });
    } catch (error) {
        console.error('[Upload] Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Ëé∑Âèñ‰∏ä‰º†ÁöÑÊñá‰ª∂ÂàóË°®
app.get('/api/files', (req, res) => {
    try {
        const files = [];
        const scanDir = (dir, type) => {
            if (fs.existsSync(dir)) {
                const items = fs.readdirSync(dir);
                items.forEach(item => {
                    const filePath = path.join(dir, item);
                    const stats = fs.statSync(filePath);
                    if (stats.isFile()) {
                        files.push({
                            id: item,
                            name: item,
                            type,
                            size: stats.size,
                            path: filePath,
                            createdAt: stats.birthtime
                        });
                    }
                });
            }
        };

        scanDir(path.join(UPLOAD_DIR, 'videos'), 'video');
        scanDir(path.join(UPLOAD_DIR, 'images'), 'image');
        scanDir(path.join(UPLOAD_DIR, 'audio'), 'audio');

        res.json({
            success: true,
            files: files.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// ============ ÊµèËßàÂô®ÂÆû‰æãÁõ∏ÂÖ≥API (ÈÄöËøáElectron HTTP API) ============

// Ëé∑ÂèñÂèØÁî®ÁöÑÊµèËßàÂô®ÂÆû‰æã
app.get('/api/browsers', async (req, res) => {
    try {
        console.log('[BrowserAPI] üîç Fetching browser instances...');

        // Ê£ÄÊü• Electron API ÂèØÁî®ÊÄß
        const isElectronAvailable = await checkElectronApiAvailability();

        if (!isElectronAvailable) {
            return res.json({
                success: true,
                browsers: [],
                message: 'Electron HTTP API not available. Please ensure Electron app is running.',
                timestamp: new Date().toISOString(),
                source: 'electron-unavailable'
            });
        }

        // ‰ªé Electron Ëé∑ÂèñÊµèËßàÂô®ÂÆû‰æã
        const browsers = await getBrowserInstancesFromElectron();

        const runningCount = browsers.filter(b => b.status === 'running').length;

        console.log(`[BrowserAPI] ‚úÖ Found ${browsers.length} browser instances (${runningCount} running)`);

        res.json({
            success: true,
            browsers,
            statistics: {
                total: browsers.length,
                running: runningCount,
                stopped: browsers.length - runningCount
            },
            timestamp: new Date().toISOString(),
            source: 'electron-http-api'
        });

    } catch (error) {
        console.error('[BrowserAPI] ‚ùå Failed to get browser instances:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            browsers: [],
            timestamp: new Date().toISOString()
        });
    }
});

// Ëé∑ÂèñÁâπÂÆöÊµèËßàÂô®ÂÆû‰æãËØ¶ÊÉÖ
app.get('/api/browsers/:browserId', async (req, res) => {
    try {
        const { browserId } = req.params;

        const isElectronAvailable = await checkElectronApiAvailability();
        if (!isElectronAvailable) {
            return res.status(503).json({
                success: false,
                error: 'Electron API not available'
            });
        }

        const browser = await getBrowserDetailsFromElectron(browserId);

        if (!browser) {
            return res.status(404).json({
                success: false,
                error: 'Browser instance not found'
            });
        }

        res.json({
            success: true,
            browser
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Ëé∑ÂèñÊµèËßàÂô®ÂÆû‰æãÁöÑÊ†áÁ≠æÈ°µ
app.get('/api/browsers/:browserId/tabs', async (req, res) => {
    try {
        const { browserId } = req.params;

        const isElectronAvailable = await checkElectronApiAvailability();
        if (!isElectronAvailable) {
            return res.status(503).json({
                success: false,
                error: 'Electron API not available'
            });
        }

        const tabs = await getBrowserTabsFromElectron(browserId);

        res.json({
            success: true,
            browserId,
            tabs
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Âà∑Êñ∞ÊµèËßàÂô®ÂÆû‰æãÁä∂ÊÄÅ
app.post('/api/browsers/refresh', async (req, res) => {
    try {
        console.log('[BrowserAPI] üîÑ Refreshing browser instances...');

        const isElectronAvailable = await checkElectronApiAvailability();
        if (!isElectronAvailable) {
            return res.status(503).json({
                success: false,
                error: 'Electron API not available'
            });
        }

        // Ë∞ÉÁî® Electron API ÁöÑÂà∑Êñ∞Êé•Âè£
        const response = await fetch(`${ELECTRON_API_BASE}/api/browsers/refresh`, {
            method: 'POST',
            timeout: 5000
        });

        if (!response.ok) {
            throw new Error(`Electron refresh API failed: ${response.status}`);
        }

        const result = await response.json();

        res.json({
            success: true,
            message: 'Browser instances refreshed via Electron API',
            electronResponse: result,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Ê£ÄÊü• Electron API Áä∂ÊÄÅÁöÑÊé•Âè£
app.get('/api/electron/status', async (req, res) => {
    try {
        const isAvailable = await checkElectronApiAvailability();

        if (isAvailable) {
            const response = await fetch(`${ELECTRON_API_BASE}/api/health`);
            const healthData = await response.json();

            res.json({
                success: true,
                available: true,
                electronApi: healthData,
                endpoint: ELECTRON_API_BASE
            });
        } else {
            res.json({
                success: true,
                available: false,
                message: 'Electron HTTP API is not responding',
                endpoint: ELECTRON_API_BASE
            });
        }
    } catch (error) {
        res.json({
            success: false,
            available: false,
            error: error.message,
            endpoint: ELECTRON_API_BASE
        });
    }
});

// ============ Â∑•‰ΩúÊµÅÊâßË°åÁõ∏ÂÖ≥API ============

// ÊâßË°åÂ∑•‰ΩúÊµÅ
app.post('/api/workflow/execute', async (req, res) => {
    try {
        const { workflowType, content, template, account, debugPort = 9711 } = req.body;

        console.log('[Workflow] ÂºÄÂßãÊâßË°åÂ∑•‰ΩúÊµÅ:', {
            type: workflowType,
            debugPort,
            account: account?.id || 'default'
        });

        // È™åËØÅÂøÖÈúÄÂèÇÊï∞
        if (!workflowType || !content) {
            return res.status(400).json({
                success: false,
                error: 'Áº∫Â∞ëÂøÖÈúÄÂèÇÊï∞: workflowType Êàñ content'
            });
        }

        // ÁîüÊàêÊâßË°åID
        const executionId = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        // ÂàõÂª∫‰∏¥Êó∂ÈÖçÁΩÆÊñá‰ª∂
        const tempConfig = await createTempConfigFiles(executionId, {
            workflowType,
            content,
            template: template || getDefaultTemplate(workflowType),
            account: account || { id: 'default', name: 'ÈªòËÆ§Ë¥¶Âè∑' }
        });

        // ÂêØÂä®Ëá™Âä®ÂåñËøõÁ®ã
        const automationResult = await executeAutomationWorkflow({
            executionId,
            workflowType,
            debugPort,
            tempConfig
        });

        // Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
        cleanupTempFiles(tempConfig);

        console.log('[Workflow] Â∑•‰ΩúÊµÅÊâßË°åÂÆåÊàê:', executionId);

        res.json({
            success: true,
            executionId,
            result: automationResult
        });

    } catch (error) {
        console.error('[Workflow] ÊâßË°åÂ§±Ë¥•:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Ëé∑ÂèñÂ∑•‰ΩúÊµÅÊâßË°åÁä∂ÊÄÅ
app.get('/api/workflow/status/:executionId', (req, res) => {
    const { executionId } = req.params;
    const workflow = activeWorkflows.get(executionId);

    if (!workflow) {
        return res.status(404).json({
            success: false,
            error: 'Â∑•‰ΩúÊµÅ‰∏çÂ≠òÂú®'
        });
    }

    res.json({
        success: true,
        status: workflow
    });
});
// ============ ‰ΩøÁî®ËØ¥Êòé ============
/*
ÂâçÁ´ØÁªÑ‰ª∂Áé∞Âú®‰ºöÈÄöËøá‰ª•‰∏ãAPIËé∑ÂèñÂπ≥Âè∞ÈÖçÁΩÆÔºö

1. GET /api/platforms - Ëé∑ÂèñÊâÄÊúâÂπ≥Âè∞ÈÖçÁΩÆ
2. POST /api/platforms/validate - È™åËØÅÂçï‰∏™Âπ≥Âè∞ÂÜÖÂÆπ
3. POST /api/platforms/adapt - ÈÄÇÈÖçÂÜÖÂÆπÂà∞Âçï‰∏™Âπ≥Âè∞
4. POST /api/platforms/adapt-multi - ÊâπÈáèÈÄÇÈÖçÂÜÖÂÆπÂà∞Â§ö‰∏™Âπ≥Âè∞
5. POST /api/workflow/multi-execute - ÊâßË°åÂ§öÂπ≥Âè∞ÂèëÂ∏ÉÂ∑•‰ΩúÊµÅ
*/

// Ëé∑ÂèñÂπ≥Âè∞ÈÖçÁΩÆ - Ê∑ªÂä†Âà∞Áé∞ÊúâË∑ØÁî±‰∏≠
app.get('/api/platforms', (req, res) => {
    try {
        // Âä®ÊÄÅÂØºÂÖ•Âπ≥Âè∞ÈÖçÁΩÆ
        import('../automation/config/platforms.js').then(({ PLATFORM_CONFIGS, getAvailablePlatforms }) => {
            const availablePlatforms = getAvailablePlatforms();

            res.json({
                success: true,
                platforms: availablePlatforms,
                configs: PLATFORM_CONFIGS,
                timestamp: new Date().toISOString()
            });
        }).catch(error => {
            console.error('[PlatformAPI] Âä†ËΩΩÂπ≥Âè∞ÈÖçÁΩÆÂ§±Ë¥•:', error);

            // ËøîÂõûÂü∫Á°ÄÈÖçÁΩÆ‰Ωú‰∏∫ÂêéÂ§á
            res.json({
                success: true,
                platforms: [
                    {
                        id: 'wechat',
                        name: 'ÂæÆ‰ø°ËßÜÈ¢ëÂè∑',
                        icon: 'üé¨',
                        color: 'bg-green-500',
                        status: 'stable',
                        fields: {
                            title: { required: false, maxLength: 16, minLength: 6 },
                            description: { required: true, maxLength: 500 }
                        },
                        features: {
                            useIframe: true,
                            needShortTitle: true,
                            supportLocation: true
                        }
                    },
                    {
                        id: 'douyin',
                        name: 'ÊäñÈü≥',
                        icon: 'üéµ',
                        color: 'bg-black',
                        status: 'testing',
                        fields: {
                            title: { required: true, maxLength: 55 },
                            description: { required: true, maxLength: 2200 }
                        },
                        features: {
                            needClickUpload: true,
                            supportHashtags: true
                        }
                    }
                ],
                fallback: true,
                timestamp: new Date().toISOString()
            });
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// È™åËØÅÂπ≥Âè∞ÂÜÖÂÆπ - Êñ∞Â¢ûAPI
app.post('/api/platforms/validate', async (req, res) => {
    try {
        const { platformId, content } = req.body;

        // Âä®ÊÄÅÂØºÂÖ•È™åËØÅÂáΩÊï∞
        const { validatePlatformContent } = await import('../automation/config/platforms.js');

        const validation = validatePlatformContent(platformId, content);

        res.json({
            success: true,
            validation,
            platformId
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// ÈÄÇÈÖçÂÜÖÂÆπÂà∞Âπ≥Âè∞ - Êñ∞Â¢ûAPI
app.post('/api/platforms/adapt', async (req, res) => {
    try {
        const { platformId, content } = req.body;

        // Âä®ÊÄÅÂØºÂÖ•ÈÄÇÈÖçÂáΩÊï∞
        const { adaptContentToPlatform } = await import('../automation/config/platforms.js');

        const adaptedContent = adaptContentToPlatform(platformId, content);

        res.json({
            success: true,
            adaptedContent,
            platformId
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// ÊâπÈáèÈÄÇÈÖçÂÜÖÂÆπÂà∞Â§ö‰∏™Âπ≥Âè∞ - Êñ∞Â¢ûAPI
app.post('/api/platforms/adapt-multi', async (req, res) => {
    try {
        const { platforms, content } = req.body;

        // Âä®ÊÄÅÂØºÂÖ•ÂáΩÊï∞
        const { adaptContentToPlatform, validatePlatformContent } = await import('../electron_browser/automation/config/platforms.js');

        const results = platforms.map(platformId => {
            const adaptedContent = adaptContentToPlatform(platformId, content);
            const validation = validatePlatformContent(platformId, adaptedContent);

            return {
                platformId,
                adaptedContent,
                validation,
                warnings: []
            };
        });

        res.json({
            success: true,
            results,
            platforms
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Â§öÂπ≥Âè∞Â∑•‰ΩúÊµÅÊâßË°å - Êñ∞Â¢ûAPI
app.post('/api/workflow/multi-execute', async (req, res) => {
    try {
        const { platforms, content, videoFile, browserMapping } = req.body;

        console.log('[MultiWorkflow] ÂºÄÂßãÂ§öÂπ≥Âè∞ÊâßË°å:', {
            platforms,
            videoFile,
            browserCount: Object.keys(browserMapping).length
        });

        // È™åËØÅÂøÖÈúÄÂèÇÊï∞
        if (!platforms || !Array.isArray(platforms) || platforms.length === 0) {
            return res.status(400).json({
                success: false,
                error: 'Áº∫Â∞ëÂπ≥Âè∞ÂèÇÊï∞'
            });
        }

        if (!content || !videoFile) {
            return res.status(400).json({
                success: false,
                error: 'Áº∫Â∞ëÂÜÖÂÆπÊàñËßÜÈ¢ëÊñá‰ª∂ÂèÇÊï∞'
            });
        }

        // Ê£ÄÊü•ÊµèËßàÂô®Êò†Â∞Ñ
        const missingMappings = platforms.filter(p => !browserMapping[p]);
        if (missingMappings.length > 0) {
            return res.status(400).json({
                success: false,
                error: `Áº∫Â∞ëÊµèËßàÂô®Êò†Â∞Ñ: ${missingMappings.join(', ')}`
            });
        }

        // ÁîüÊàêÊâßË°åID
        const executionId = `multi_exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        // ‰∏∫ÊØè‰∏™Âπ≥Âè∞ÂàõÂª∫ÂçïÁã¨ÁöÑ‰ªªÂä°
        const platformTasks = platforms.map(async (platformId) => {
            try {
                console.log(`[MultiWorkflow] ÂºÄÂßãÊâßË°åÂπ≥Âè∞: ${platformId}`);

                // Ëé∑ÂèñÂπ≥Âè∞ÈÖçÁΩÆ
                const { getPlatformConfig, adaptContentToPlatform } = await import('../automation/config/platforms.js');
                const platformConfig = getPlatformConfig(platformId);

                if (!platformConfig) {
                    throw new Error(`Âπ≥Âè∞ÈÖçÁΩÆ‰∏çÂ≠òÂú®: ${platformId}`);
                }

                // ÈÄÇÈÖçÂÜÖÂÆπ
                const adaptedContent = adaptContentToPlatform(platformId, content);

                // ÂàõÂª∫Âπ≥Âè∞ÁâπÂÆöÁöÑ‰∏¥Êó∂ÈÖçÁΩÆ
                const platformTempConfig = await createTempConfigFiles(`${executionId}_${platformId}`, {
                    workflowType: 'video',
                    content: {
                        ...adaptedContent,
                        videoFile: videoFile
                    },
                    template: getDefaultTemplate('video'),
                    account: {
                        id: browserMapping[platformId],
                        name: `${platformConfig.name}Ë¥¶Âè∑`,
                        platform: platformId
                    }
                });

                // ÊâßË°åÂçïÂπ≥Âè∞Â∑•‰ΩúÊµÅ
                const result = await executeAutomationWorkflow({
                    executionId: `${executionId}_${platformId}`,
                    workflowType: 'video',
                    platform: platformId,
                    debugPort: 9225, // ÂèØ‰ª•‰ªébrowserMapping‰∏≠Ëé∑ÂèñÂÖ∑‰ΩìÁ´ØÂè£
                    tempConfig: platformTempConfig
                });

                // Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
                cleanupTempFiles(platformTempConfig);

                return {
                    platform: platformId,
                    platformName: platformConfig.name,
                    success: true,
                    result,
                    adaptedContent
                };

            } catch (error) {
                console.error(`[MultiWorkflow] Âπ≥Âè∞ ${platformId} ÊâßË°åÂ§±Ë¥•:`, error.message);
                return {
                    platform: platformId,
                    platformName: platformId,
                    success: false,
                    error: error.message
                };
            }
        });

        // Âπ∂Ë°åÊâßË°åÊâÄÊúâÂπ≥Âè∞‰ªªÂä°
        console.log(`[MultiWorkflow] ÂºÄÂßãÂπ∂Ë°åÊâßË°å ${platforms.length} ‰∏™Âπ≥Âè∞...`);
        const results = await Promise.allSettled(platformTasks);

        // Â§ÑÁêÜÁªìÊûú
        const processedResults = results.map((result, index) => {
            if (result.status === 'fulfilled') {
                return result.value;
            } else {
                return {
                    platform: platforms[index],
                    success: false,
                    error: result.reason?.message || String(result.reason)
                };
            }
        });

        const successCount = processedResults.filter(r => r.success).length;
        const failureCount = processedResults.length - successCount;

        console.log(`[MultiWorkflow] Â§öÂπ≥Âè∞ÊâßË°åÂÆåÊàê: ÊàêÂäü ${successCount}, Â§±Ë¥• ${failureCount}`);

        res.json({
            success: successCount > 0,
            executionId,
            totalPlatforms: platforms.length,
            successCount,
            failureCount,
            results: processedResults,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('[MultiWorkflow] ÊâßË°åÂ§±Ë¥•:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// ============ Â∑•ÂÖ∑ÂáΩÊï∞Êâ©Â±ï ============

// Êâ©Â±ïÁé∞ÊúâÁöÑ executeAutomationWorkflow ÂáΩÊï∞‰ª•ÊîØÊåÅÂπ≥Âè∞ÂèÇÊï∞
function executeAutomationWorkflowWithPlatform({ executionId, workflowType, platform, debugPort, tempConfig }) {
    return new Promise((resolve, reject) => {
        // ‰øÆÊîπ CLI Ë∑ØÂæÑÊü•ÊâæÈÄªËæë
        const automationPath = path.join(__dirname, '../automation');
        const cliPath = path.join(automationPath, 'cli/automation-cli.js');

        // Ê£ÄÊü•Êñ∞ÁöÑÂ§öÂπ≥Âè∞CLIÊòØÂê¶Â≠òÂú®
        let finalCliPath = cliPath;
        if (fs.existsSync(path.join(automationPath, 'cli/multi-platform-cli.js'))) {
            finalCliPath = path.join(automationPath, 'cli/multi-platform-cli.js');
        }

        const args = [
            'publish',
            '-t', workflowType,
            '-c', tempConfig.contentFile,
            '-a', tempConfig.accountFile,
            '-p', tempConfig.templateFile,
            '--debug-port', debugPort.toString()
        ];

        // Â¶ÇÊûúÊîØÊåÅÂπ≥Âè∞ÂèÇÊï∞ÔºåÊ∑ªÂä†Âπ≥Âè∞ID
        if (platform) {
            args.push('--platform', platform);
        }

        console.log('[Automation] ÊâßË°åÂ§öÂπ≥Âè∞ÂëΩ‰ª§:', 'node', finalCliPath, ...args);

        const process = spawn('node', [finalCliPath, ...args], {
            cwd: automationPath,
            stdio: ['pipe', 'pipe', 'pipe']
        });

        let output = '';
        let errorOutput = '';

        process.stdout.on('data', (data) => {
            const text = data.toString();
            output += text;
            console.log(`[Automation-${platform || workflowType}-${executionId}]`, text);
        });

        process.stderr.on('data', (data) => {
            const text = data.toString();
            errorOutput += text;
            console.error(`[Automation-Error-${platform || workflowType}-${executionId}]`, text);
        });

        process.on('close', (code) => {
            if (code === 0) {
                console.log(`[Automation] Âπ≥Âè∞ ${platform} Â∑•‰ΩúÊµÅ ${executionId} ÊâßË°åÊàêÂäü`);
                resolve({
                    success: true,
                    executionId,
                    platform,
                    output,
                    workflowType,
                    exitCode: code
                });
            } else {
                console.error(`[Automation] Âπ≥Âè∞ ${platform} Â∑•‰ΩúÊµÅ ${executionId} ÊâßË°åÂ§±Ë¥•ÔºåÈÄÄÂá∫Á†Å: ${code}`);
                reject(new Error(`Âπ≥Âè∞ ${platform} Â∑•‰ΩúÊµÅÊâßË°åÂ§±Ë¥•ÔºåÈÄÄÂá∫Á†Å: ${code}\n${errorOutput}`));
            }
        });

        process.on('error', (error) => {
            console.error(`[Automation] Âπ≥Âè∞ ${platform} ËøõÁ®ãÂêØÂä®Â§±Ë¥•:`, error);
            reject(error);
        });
    });
}


// ============ Â∑•ÂÖ∑ÂáΩÊï∞ ============

// ÂàõÂª∫‰∏¥Êó∂ÈÖçÁΩÆÊñá‰ª∂
async function createTempConfigFiles(executionId, config) {
    const tempDir = path.join(TEMP_DIR, executionId);
    if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
    }

    const files = {
        contentFile: path.join(tempDir, 'content.json'),
        templateFile: path.join(tempDir, 'template.json'),
        accountFile: path.join(tempDir, 'account.json')
    };

    // Â§ÑÁêÜÊñá‰ª∂Ë∑ØÂæÑ
    if (config.content.videoFile && !path.isAbsolute(config.content.videoFile)) {
        const videoPath = path.join(UPLOAD_DIR, 'videos', config.content.videoFile);
        if (fs.existsSync(videoPath)) {
            config.content.videoFile = videoPath;
        }
    }

    fs.writeFileSync(files.contentFile, JSON.stringify(config.content, null, 2));
    fs.writeFileSync(files.templateFile, JSON.stringify(config.template, null, 2));
    fs.writeFileSync(files.accountFile, JSON.stringify(config.account, null, 2));

    return files;
}

// ÊâßË°åËá™Âä®ÂåñÂ∑•‰ΩúÊµÅ
function executeAutomationWorkflow({ executionId, workflowType, debugPort, tempConfig }) {
    return new Promise((resolve, reject) => {
        // üîß ‰øÆÂ§çÔºö‰ΩøÁî®Ê≠£Á°ÆÁöÑ automation Ë∑ØÂæÑ
        // ‰ªéÂΩìÂâç rpa-platform ÁõÆÂΩïÊâæÂà∞ electron_browser/automation
        const automationPath = path.join(__dirname, '../electron_browser/automation');
        const cliPath = path.join(automationPath, 'cli/automation-cli.js');

        console.log('[Automation] Êü•ÊâæË∑ØÂæÑ:', {
            currentDir: __dirname,
            automationPath: automationPath,
            cliPath: cliPath
        });

        let finalCliPath = cliPath;
        let finalAutomationPath = automationPath;

        // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
        if (!fs.existsSync(cliPath)) {
            // üîß Â∞ùËØïÂÖ∂‰ªñÂèØËÉΩÁöÑË∑ØÂæÑ
            const alternativePaths = [
                path.join(__dirname, '../automation/cli/automation-cli.js'),
                path.join(__dirname, '../../automation/cli/automation-cli.js'),
                path.join(__dirname, '../electron_browser/automation/cli/automation-cli.js'),
                path.join(process.cwd(), '../automation/cli/automation-cli.js'),
                path.join(process.cwd(), '../electron_browser/automation/cli/automation-cli.js')
            ];

            console.log('[Automation] CLIÊñá‰ª∂‰∏çÂ≠òÂú®ÔºåÂ∞ùËØïÂÖ∂‰ªñË∑ØÂæÑ:');
            let foundPath = null;

            for (const altPath of alternativePaths) {
                console.log('[Automation] Ê£ÄÊü•:', altPath);
                if (fs.existsSync(altPath)) {
                    foundPath = altPath;
                    console.log('[Automation] ‚úÖ ÊâæÂà∞CLIÊñá‰ª∂:', foundPath);
                    break;
                }
            }

            if (!foundPath) {
                const error = `Automation CLI ‰∏çÂ≠òÂú®ÔºåÂ∑≤Ê£ÄÊü•Ë∑ØÂæÑ:\n${[cliPath, ...alternativePaths].join('\n')}`;
                console.error('[Automation]', error);
                reject(new Error(error));
                return;
            }

            // Êõ¥Êñ∞ÊâæÂà∞ÁöÑË∑ØÂæÑ
            finalCliPath = foundPath;
            finalAutomationPath = path.dirname(path.dirname(foundPath));
        } else {
            console.log('[Automation] ‚úÖ ÊâæÂà∞CLIÊñá‰ª∂:', cliPath);
        }

        const args = [
            'publish',
            '-t', workflowType,
            '-c', tempConfig.contentFile,
            '-a', tempConfig.accountFile,
            '-p', tempConfig.templateFile,
            '--debug-port', debugPort.toString()
        ];

        console.log('[Automation] ÊâßË°åÂëΩ‰ª§:', 'node', finalCliPath, ...args);
        console.log('[Automation] Â∑•‰ΩúÁõÆÂΩï:', finalAutomationPath);

        const process = spawn('node', [finalCliPath, ...args], {
            cwd: finalAutomationPath,
            stdio: ['pipe', 'pipe', 'pipe']
        });

        let output = '';
        let errorOutput = '';

        // ËÆ∞ÂΩïÂ∑•‰ΩúÊµÅÁä∂ÊÄÅ
        activeWorkflows.set(executionId, {
            id: executionId,
            status: 'running',
            startTime: new Date().toISOString(),
            workflowType,
            debugPort,
            progress: 0
        });

        process.stdout.on('data', (data) => {
            const text = data.toString();
            output += text;
            console.log(`[Automation-${executionId}]`, text);

            // Êõ¥Êñ∞ËøõÂ∫¶ÔºàÁÆÄÂçïÁöÑÊñáÊú¨ÂåπÈÖçÔºâ
            let progress = 0;
            if (text.includes('Êñá‰ª∂‰∏ä‰º†ÊàêÂäü')) progress = 30;
            else if (text.includes('Â°´ÂÜô')) progress = 60;
            else if (text.includes('ÂèëÂ∏É')) progress = 90;

            if (progress > 0) {
                const workflow = activeWorkflows.get(executionId);
                if (workflow) {
                    workflow.progress = progress;
                    activeWorkflows.set(executionId, workflow);
                }
            }
        });

        process.stderr.on('data', (data) => {
            const text = data.toString();
            errorOutput += text;
            console.error(`[Automation-Error-${executionId}]`, text);
        });

        process.on('close', (code) => {
            const workflow = activeWorkflows.get(executionId);

            if (code === 0) {
                console.log(`[Automation] Â∑•‰ΩúÊµÅ ${executionId} ÊâßË°åÊàêÂäü`);

                if (workflow) {
                    workflow.status = 'completed';
                    workflow.progress = 100;
                    workflow.endTime = new Date().toISOString();
                    activeWorkflows.set(executionId, workflow);
                }

                resolve({
                    success: true,
                    executionId,
                    output,
                    workflowType,
                    exitCode: code
                });
            } else {
                console.error(`[Automation] Â∑•‰ΩúÊµÅ ${executionId} ÊâßË°åÂ§±Ë¥•ÔºåÈÄÄÂá∫Á†Å: ${code}`);

                if (workflow) {
                    workflow.status = 'failed';
                    workflow.error = errorOutput;
                    workflow.endTime = new Date().toISOString();
                    activeWorkflows.set(executionId, workflow);
                }

                reject(new Error(`Â∑•‰ΩúÊµÅÊâßË°åÂ§±Ë¥•ÔºåÈÄÄÂá∫Á†Å: ${code}\n${errorOutput}`));
            }
        });

        process.on('error', (error) => {
            console.error(`[Automation] ËøõÁ®ãÂêØÂä®Â§±Ë¥•:`, error);

            const workflow = activeWorkflows.get(executionId);
            if (workflow) {
                workflow.status = 'failed';
                workflow.error = error.message;
                workflow.endTime = new Date().toISOString();
                activeWorkflows.set(executionId, workflow);
            }

            reject(error);
        });
    });
}

// Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
function cleanupTempFiles(tempConfig) {
    try {
        Object.values(tempConfig).forEach(filePath => {
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
            }
        });

        // Âà†Èô§‰∏¥Êó∂ÁõÆÂΩï
        const tempDir = path.dirname(tempConfig.contentFile);
        if (fs.existsSync(tempDir)) {
            fs.rmSync(tempDir, { recursive: true });
        }
    } catch (error) {
        console.warn('[Cleanup] Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂Â§±Ë¥•:', error.message);
    }
}

// Ëé∑ÂèñÈªòËÆ§Ê®°Êùø
function getDefaultTemplate(workflowType) {
    const templates = {
        video: {
            description: '{{description}} - ÂèëÂ∏É‰∫é{{date}} #{{account.name}}',
            location: '{{location}}'
        },
        article: {
            title: '{{title}} - {{account.name}}',
            content: '{{content}}\n\nÂèëÂ∏ÉÊó∂Èó¥: {{time}}'
        },
        music: {
            title: '{{title}} - Èü≥‰πêÂàÜ‰∫´',
            description: '{{description}} #Èü≥‰πê #{{account.name}}'
        },
        audio: {
            title: '{{title}} - Èü≥È¢ëÂÜÖÂÆπ',
            description: '{{description}} #Èü≥È¢ë #{{account.name}}'
        }
    };

    return templates[workflowType] || templates.video;
}

// ÂêØÂä®ÊúçÂä°Âô®
app.listen(PORT, () => {
    console.log(`üöÄ RPA Platform ÂêéÁ´ØÊúçÂä°ÂêØÂä®Âú®Á´ØÂè£ ${PORT}`);
    console.log(`üìÅ ‰∏ä‰º†ÁõÆÂΩï: ${UPLOAD_DIR}`);
    console.log(`üìÑ ‰∏¥Êó∂ÁõÆÂΩï: ${TEMP_DIR}`);
    console.log(`üìù Êó•ÂøóÁõÆÂΩï: ${LOGS_DIR}`);
    console.log(`üîó Electron API Á´ØÁÇπ: ${ELECTRON_API_BASE}`);
});

// ‰ºòÈõÖÈÄÄÂá∫
process.on('SIGINT', () => {
    console.log('\nüì§ Ê≠£Âú®ÂÖ≥Èó≠ÊúçÂä°Âô®...');
    process.exit(0);
});

module.exports = app;